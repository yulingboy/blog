这里我想的是，超级管理员能修改所有人的个人信息，其他人只能修改自己的个人信息，所以发起请求的时候需要判断

创建路由

```js
router.put('/users/:id',user.edit); // 编辑用户信息
```

将函数进行导出

```js
// 编辑用户信息
exports.edit = async (req,res)=>{
    
}
```

判断用户权限

```js
// 根据ID查询用户信息
        const user = await User.find({_id:req.params.id})
        // 先判断是否有这个用户
        if(!user){
            res.send({
                meta: { code: 1001, message: '用户不存在' },
                data: null,
              });
        }
        // 如果发起请求的人不是当前登录人，且角色不是超级管理员，则无法更改用户信息
        if(req.user.role == 2 && user.email == req.user.email){
            // 验证通过
        }else{
            res.send({
                meta: { code: 1001, message: '权限不足' },
                data: null,
              });
        }
```

验证通过

```js
 // 权限验证通过，可以修改用户信息
      req.body = JSON.parse(JSON.stringify(req.body));
      await User.findOneAndUpdate({ _id: req.params.id },{ $set: req.body },{ new: true })
        .then(() => {
          return res.send({
            meta: { code: 1000, message: '修改成功' },
            data: null,
          });
        })
        .catch((err) => {
          return res.send({
            meta: { code: 1001, message: err.message },
            data: null,
          });
        });
```

突然发现一个问题，就是说，如果我当前成功登陆，岂不是普通用户也能够更改自己的权限，改成超级管理员？

看来也得判断一下，如果你的角色不是超级管理员，就不能修改用户角色

```js
if(req.user.role && req.user.role != 2 && req.user.role != req.body.role ){
    return res.send({
       meta: { code: 1001, message: '权限不足' },
       data: null,
   });
}
```

这里有个坑，就是我上面根据ID查找用户时，使用的是find，所以返回的是一个数组，当没有查到用户时，返回的是一个空数组，我在给他取反，此时，结果就为true了，没有起到判断作用，所以需要使用findOne方法

修改用户信息完整代码

```js
// 编辑用户信息
exports.edit = async (req, res) => {
  try {
    // 根据ID查询用户信息
    const user = await User.findOne({ _id: req.params.id });
    // 先判断是否有这个用户
    if (!user) {
      return res.send({
        meta: { code: 1001, message: '用户不存在' },
        data: null,
      });
    }
    // 如果发起请求的人不是当前登录人，或者角色不是超级管理员，则无法更改用户信息
    if (req.user.email == req.body.email || req.user.role == 2) {
      // 权限验证通过，可以修改用户信息
      req.body = JSON.parse(JSON.stringify(req.body));
      // 如果当前登录人不是超级管理员，那么不允许修改权限
      if(req.user.role && req.user.role != 2 && req.user.role != req.body.role ){
        return res.send({
            meta: { code: 1001, message: '权限不足' },
            data: null,
          });
      }
      await User.findOneAndUpdate({ _id: req.params.id },{ $set: req.body },{ new: true })
        .then(() => {
          return res.send({
            meta: { code: 1000, message: '修改成功' },
            data: null,
          });
        })
        .catch((err) => {
          return res.send({
            meta: { code: 1001, message: err.message },
            data: null,
          });
        });
    } else {
      return res.send({
        meta: { code: 1001, message: '权限不足' },
        data: null,
      });
    }
  } catch (err) {
    return res.send({
      meta: { code: 1001, message: err.message },
      data: null,
    });
  }
};
```

这里有个坑，是后面才发现的，这里的修改用户信息，密码也是可以修改的，所以修改后的密码需要进行加密，吐血



